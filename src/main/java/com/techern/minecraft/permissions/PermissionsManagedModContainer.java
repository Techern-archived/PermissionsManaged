package com.techern.minecraft.permissions;

import com.google.common.collect.ImmutableList;
import com.google.common.eventbus.EventBus;
import net.minecraftforge.fml.common.*;
import net.minecraftforge.fml.common.versioning.ArtifactVersion;
import net.minecraftforge.fml.common.versioning.DefaultArtifactVersion;
import net.minecraftforge.fml.common.versioning.VersionRange;

import java.io.File;
import java.net.URL;
import java.security.cert.Certificate;
import java.util.*;

/**
 * An implementation of {@link ModContainer} for {@link PermissionsManaged}
 *
 * @since 0.0.1
 */
public class PermissionsManagedModContainer implements ModContainer {

    /**
     * The {@link ModMetadata} for {@link PermissionsManaged}
     *
     * @since 0.0.1
     */
    public static ModMetadata METADATA = new ModMetadata();

    static {

        METADATA.authorList.add("Cruz Julian Bishop (Syntaxial)");
        METADATA.authorList.add("Jordan Ferreira");
        METADATA.authorList.add("Jamie & Christina Probst");

        METADATA.autogenerated = false;

        METADATA.credits = "The Minecraft team for being so damned slow";

        METADATA.description = "A core mod providing permissions for your Minecraft server";

        METADATA.modId = "PermissionsManaged";

        METADATA.name = "Permissions Managed";

        METADATA.version = PermissionsManaged.VERSION;
    }

    /**
     * The globally unique mod ID for this mod
     *
     * @since 0.0.1
     */
    @Override
    public String getModId() {
        return "PermissionsManaged";
    }

    /**
     * A human readable name
     *
     * @since 0.0.1
     */
    @Override
    public String getName() {
        return "Permissions Managed";
    }

    /**
     * A human readable version identifier
     *
     * @since 0.0.1
     */
    @Override
    public String getVersion() {
        return PermissionsManaged.VERSION;
    }

    /**
     * The location on the file system which this mod came from
     *
     * @since 0.0.1
     * TODO: This
     */
    @Override
    public File getSource() {
        return null;
    }

    /**
     * The metadata for this mod
     *
     * @since 0.0.1
     */
    @Override
    public ModMetadata getMetadata() {
        return METADATA;
    }

    /**
     * Attach this mod to it's metadata from the supplied metadata collection
     *
     * @param mc The {@link MetadataCollection}
     *
     * @since 0.0.1
     */
    @Override
    public void bindMetadata(MetadataCollection mc) {
        PermissionsManaged.LOGGER.info("Got a request to bind with " + mc);
    }

    /**
     * Set the enabled/disabled state of this mod
     *
     * @param enabled
     */
    @Override
    public void setEnabledState(boolean enabled) {
        PermissionsManaged.LOGGER.info("Got a request to set enabled state to " + enabled);
    }

    /**
     * A list of the modids that this mod requires loaded prior to loading
     */
    @Override
    public Set<ArtifactVersion> getRequirements() {
        return Collections.emptySet();
    }

    /**
     * A list of modids that should be loaded prior to this one. The special
     * value <strong>*</strong> indicates to load <em>after</em> any other mod.
     */
    @Override
    public List<ArtifactVersion> getDependencies() {
        return Collections.emptyList();
    }

    /**
     * A list of modids that should be loaded <em>after</em> this one. The
     * special value <strong>*</strong> indicates to load <em>before</em> any
     * other mod.
     */
    @Override
    public List<ArtifactVersion> getDependants() {
        return Collections.emptyList();
    }

    /**
     * A representative string encapsulating the sorting preferences for this
     * mod
     */
    @Override
    public String getSortingRules() {
        return "";
    }

    /**
     * Register the event bus for the mod and the controller for error handling
     * Returns if this bus was successfully registered - disabled mods and other
     * mods that don't need real events should return false and avoid further
     * processing
     *
     * @param bus
     * @param controller
     */
    @Override
    public boolean registerBus(EventBus bus, LoadController controller) {
        return false;
    }

    /**
     * Does this mod match the supplied mod
     *
     * @param mod
     */
    @Override
    public boolean matches(Object mod) {
        return false;
    }

    /**
     * Get the actual mod object
     */
    @Override
    public Object getMod() {
        return null;
    }

    private ArtifactVersion processedVersion;

    @Override
    public ArtifactVersion getProcessedVersion() {
        if (processedVersion == null)
        {
            processedVersion = new DefaultArtifactVersion(getModId(), getVersion());
        }
        return processedVersion;
    }

    @Override
    public boolean isImmutable() {
        return false;
    }

    @Override
    public String getDisplayVersion() {
        return METADATA.version;
    }

    @Override
    public VersionRange acceptableMinecraftVersionRange() {
        return Loader.instance().getMinecraftModContainer().getStaticVersionRange();
    }

    @Override
    public Certificate getSigningCertificate() {
        return null;
    }

    @Override
    public Map<String, String> getCustomModProperties() {
        return EMPTY_PROPERTIES;
    }

    @Override
    public Class<?> getCustomResourcePackClass() {
        return null;
    }

    @Override
    public Map<String, String> getSharedModDescriptor() {
        return null;
    }

    @Override
    public Disableable canBeDisabled() {
        return Disableable.NEVER;
    }

    @Override
    public String getGuiClassName() {
        return null;
    }

    @Override
    public List<String> getOwnedPackages() {
        return ImmutableList.of();
    }

    @Override
    public boolean shouldLoadInEnvironment() {
        return true;
    }

    @Override
    public URL getUpdateUrl() {
        return null;
    }
}
